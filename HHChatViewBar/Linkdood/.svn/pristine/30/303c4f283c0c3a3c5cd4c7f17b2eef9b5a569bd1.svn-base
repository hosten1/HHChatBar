//
//  LDMessageModel.m
//  SDKClient
//
//  Created by xiong qing on 16/3/1.
//  Copyright © 2016年 VRV. All rights reserved.
//

#import "LDMessageModel.h"

@implementation LDMessageModel

- (instancetype)init
{
    if (self = [super init]) {
        self.sendUserID = MYSELF.ID;
        self.relatedMsgID = 0;
        self.activeType = 0;
        self.msgProperties = [@{@"deviceType":[NSNumber numberWithInt:2],@"timeZone":[NSNumber numberWithInteger:[[NSTimeZone systemTimeZone] secondsFromGMT] * 4 / 3600]} JSONString];
        self.limitRange = [[NSMutableArray alloc] initWithCapacity:0];
        self.relatedUsers = [[NSMutableArray alloc] initWithCapacity:0];
    }
    return self;
}

-(void)setMsgProperties:(NSString *)msgProperties
{
    if ([msgProperties jsonType] == JSON_TYPE_DICTIONARY) {
        NSMutableDictionary *msgDic = [[NSMutableDictionary alloc] initWithDictionary:_msgProperties.objectFromJSONString];
        [msgDic addEntriesFromDictionary:msgProperties.objectFromJSONString];
        _msgProperties = [msgDic JSONString];
    }
}

+ (instancetype)modelWithStruct:(void *)structural forStructType:(struct_type)type
{
    imsdk::st_msgBean *msg = (imsdk::st_msgBean*)structural;
    LDMessageModel *message = [[LDMessageModel alloc] init];
    if (msg->messageType == MESSAGE_TYPE_TEXT) {
        message = [[LDTextMessageModel alloc] init];
        NSString *msgString = transformTextMessage([NSString stringWithCString:msg->message.c_str() encoding:NSUTF8StringEncoding]);
        if ([msgString rangeOfString:DirectiveShake].location != NSNotFound || [msgString rangeOfString:DirectivedelDelToday].location != NSNotFound || [msgString rangeOfString:DirectivedelDelAll].location != NSNotFound) {
            message = [[LDDirectiveMessageModel alloc] init];
        }
    }
    if (msg->messageType == MESSAGE_TYPE_CARD) {
        message = [[LDCardMessageModel alloc] init];
    }
    if (msg->messageType == MESSAGE_TYPE_LOCATION) {
        message = [[LDLocationMessageModel alloc] init];
    }
    if (msg->messageType == MESSAGE_TYPE_IMAGE) {
        message = [[LDImageMessageModel alloc] init];
    }
    if (msg->messageType == MESSAGE_TYPE_AUDIO) {
        message = [[LDAudioMessageModel alloc] init];
    }
    if (msg->messageType == MESSAGE_TYPE_FILE) {
        message = [[LDFileMessageModel alloc] init];
    }
    if (msg->messageType == MESSAGE_TYPE_TASK) {
        message = [[LDTaskMessageModel alloc] init];
    }
    if (msg->messageType == MESSAGE_TYPE_EXPRESSTIONS){
        message = [[LDExpressionMessageModel alloc] init];
    }
    if (msg->messageType == MESSAGE_TYPE_ASSEMBLE){
        message = [[LDComboMessageModel alloc] init];
    }
    message.ID = msg->messageID;
    message.timestamp = msg->sendTime;
    message.lastMessageID = msg->lastMessageID;
    message.messageType = msg->messageType & 0x00FF;
    int16_t errorType = msg->messageType & 0xFF00;
    message.status = (msg_status)errorType;
    message.message = [NSString stringWithCString:msg->message.c_str() encoding:NSUTF8StringEncoding];
    message.sendUserID = msg->sendUserID;
    message.receTargetID = msg->receTargetID;
    
    message.msgProperties = [NSString stringWithCString:msg->msgProperties.c_str() encoding:NSUTF8StringEncoding];
    message.relatedMsgID = msg->relatedMsgID;
    message.activeType = msg->activeType;
    std::vector<int64>::iterator limit;
    for (limit = msg->limitRange.begin(); limit != msg->limitRange.end(); limit++) {
        [message.limitRange addObject:[NSNumber numberWithLongLong:*limit]];
    }
    std::vector<int64_t>::iterator user;
    for (user = msg->relatedUsers.begin(); user != msg->relatedUsers.end(); user++) {
        [message.relatedUsers addObject:[NSNumber numberWithLongLong:*user]];
    }
    
    return message;
}

-(void)transformToRequest:(void **)reqData witCmd:(unsigned short)cmd
{
    if (cmd == imsdk::logic_cmd_sendMessage || cmd == imsdkldd::ldd_logic_cmd_sendTaskMsg) {
        imsdk::req_sendMessage *req = new imsdk::req_sendMessage();
        req->targetID = self.receTargetID;
        req->message = [self.message UTF8String];
        req->messageType = self.messageType;
        req->maccode = [DEVICEMAC UTF8String];
        for (NSNumber *userID in self.limitRange) {
            req->limitRange.push_back([userID longLongValue]);
        }
        for (NSNumber *userID in self.relatedUsers) {
            req->relatedUsers.push_back([userID longLongValue]);
        }
        if (self.msgProperties) {
            req->msgProperties = [self.msgProperties UTF8String];
        }
        req->activeType = self.activeType;
        req->relatedMsgID = 0;
        *reqData = req;
        return;
    }
}

- (void)callbackByResponse:(void *)rspData witCmd:(unsigned short)cmd
{
    if (cmd == imsdk::logic_cmd_sendMessage || cmd == imsdkldd::ldd_logic_cmd_sendTaskMsg) {
        MessageSendStatus status = objc_getAssociatedObject(self, "messageSendStatus");
        imsdk::resp_sendMessage *resp = (imsdk::resp_sendMessage*)rspData;
        if (resp->code == 0) {
            self.ID = resp->messageID;
            self.lastMessageID = resp->lastMessageID;
            self.timestamp = resp->sendTime;
            self.status = msg_normal;
            if (status) {
                MainQue(status(msg_normal););
            }
        }else{
            self.status = msg_failure;
            if (status) {
                MainQue(status(msg_failure););
            }
        }
    }
}

-(void)dealloc
{
    objc_removeAssociatedObjects(self);
}

@end
